#include "tangram_bam.h"
#include <stdio.h>
#include <limits.h>
#include <getopt.h>

#include <vector>
#include <string>
#include <iostream>

#include "api/BamReader.h"
#include "api/BamWriter.h"
#include "../OutSources/fasta/Fasta.h"
#include "../OutSources/stripedSW/ssw_cpp.h"

using namespace std;

void ShowHelp() {
  fprintf(stderr, "Usage: tangram_bam <in_bam> <ref_fa> <out_bam>\n\n");
  fprintf(stderr, "tangram_bam will generate ZA tags for bams");
  fprintf(stderr, " that are not generated by MOSAIK.\n");

  fprintf(stderr, "<ref_fa> is a fasta file containing insertion sequences\n");
  fprintf(stderr, " that we are going to detect them.\n");
}

bool OpenBams(
    const string& infilename,
    const string& outfilename,
    const string& command_line,
    BamTools::BamReader* reader,
    BamTools::BamWriter* writer) {
  
  reader->Open(infilename);
  if (!reader->IsOpen()) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", infilename.c_str());
    return false;
  }

  // Load header and ref
  string header = reader->GetHeaderText();
  size_t pos1 = header.find("SO:");
  if (pos1 != string::npos) {
    size_t pos2 = header.find("SO:queryname");
    if (pos2 != string::npos) header.replace(pos2, 12, "SO:unsorted");
    pos2 = header.find("SO:coordinate");
    if (pos2 != string::npos) header.replace(pos2, 13, "SO:unsorted");
  }
  header += "@PG\tID:tangram_bam\tCL:";
  header += (command_line + '\n');
  BamTools::RefVector ref = reader->GetReferenceData();

  if (!writer->Open(outfilename, header, ref)) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", outfilename.c_str());
    reader->Close();
    return false;
  }

  return true;
}

inline bool LoadReference(const char* fa, FastaReference* fasta) {
  string filename = fa;
  fasta->open(filename);

  return true;
}

bool ConcatenateSpecialReference(
    FastaReference* fasta, 
    SpecialReference* s_ref) {
  int total_len = 0;
  for (vector<string>::const_iterator ite = fasta->index->sequenceNames.begin();
       ite != fasta->index->sequenceNames.end(); ++ite) {
    s_ref->concatnated += fasta->getSequence(*ite).c_str();
    s_ref->ref_lens.push_back(fasta->sequenceLength(*ite));
    s_ref->ref_names.push_back(*ite);
    total_len += fasta->sequenceLength(*ite);
  }

  s_ref->concatnated_len = total_len;

  return true;
}

void GetReverseComplement(const string& query, string* reverse) {
  reverse->clear();

  for (string::const_reverse_iterator ite = query.rbegin(); ite != query.rend(); ++ite) {
    switch(*ite) {
      case 'A': *reverse += 'T'; break;
      case 'C': *reverse += 'G'; break;
      case 'G': *reverse += 'C'; break;
      case 'T': *reverse += 'A'; break;
      default: *reverse += 'N';
    }
  }
}

void Align(
    const string& query,
    const StripedSmithWaterman::Aligner& aligner,
    StripedSmithWaterman::Alignment* alignment) {
    
    alignment->Clear();
    aligner.Align(query.c_str(), kFilter, alignment);
}

void GetZa(const Alignment& al, const Alignment& mate, string* za) {
  const bool mate1 = al.bam_alignment.IsFirstMate();
  Alignment const *mate1_ptr, *mate2_ptr;

  if (mate1) {
    *za = "<@;";
    mate1_ptr = &al;
    mate2_ptr = &mate;
  } else {
    *za = "<&;";
    mate1_ptr = &mate;
    mate2_ptr = &al;
  }

  *za += (std::to_string(mate1_ptr->bam_alignment.MapQuality) + ";;" 
          + (mate1_ptr->hit_insertion ? mate1_ptr->ins_prefix : "") 
	  + ";1;");
  
  if (mate1) {
    *za += ";><&;";
  } else {
    *za += ";><@;";
  }

  *za += (std::to_string(mate2_ptr->bam_alignment.MapQuality) + ";;" 
          + (mate2_ptr->hit_insertion ? mate2_ptr->ins_prefix : "") 
	  + ";1;;>");

}

void WriteAlignment(
    const bool& add_za,
    const Alignment& mate,
    Alignment* al,
    BamTools::BamWriter* writer) {
  
  if (add_za) {
    string za;
    GetZa(*al, mate, &za);
    al->bam_alignment.AddTag("ZA","Z",za);
  }

  writer->SaveAlignment(al->bam_alignment);
}

void WriteAlignment(const bool& add_za,
                    map<string, Alignment>* al_map_ite, 
                    BamTools::BamWriter* writer) {
		    
  for (map<string, Alignment>::iterator ite = al_map_ite->begin();
       ite != al_map_ite->end(); ++ite) {
    Alignment* al = &(ite->second);
    if (add_za) {
      string za;
      if (al->bam_alignment.IsPaired()) { // paired-end read
        if (al->bam_alignment.IsFirstMate()) {
          za = "<@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
               + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>"
	       + "<&;0;;;0;;>";
        } else {
          za = "<&;0;;;0;;><@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
               + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>";
        }
      } else { // sinle-end read
        za = "<@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
             + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>";
      }

      al->bam_alignment.AddTag("ZA","Z",za);
    }

    writer->SaveAlignment(al->bam_alignment);
  }
}

// Return true if an alignment contains too many soft clips
inline bool IsTooManyClips (const BamTools::BamAlignment& al) {
  if (al.CigarData.empty()) return true;

  int clip = 0;
  if ((al.CigarData.begin())->Type == 'S') clip += (al.CigarData.begin())->Length;
  if ((al.CigarData.rbegin())->Type == 'S') clip += (al.CigarData.rbegin())->Length;

  if (clip > (al.Length * kSoftClipRate)) return true;
  else return false;
}

inline void MarkAsUnmapped (BamTools::BamAlignment* al, BamTools::BamAlignment* mate) {
  const bool al_unmapped   = IsTooManyClips(*al);
  const bool mate_unmapped = IsTooManyClips(*mate);

  if (!al_unmapped && !mate_unmapped) {
    // nothing
  } else {
    al->SetIsMapped(!al_unmapped);
    mate->SetIsMapped(!mate_unmapped);
    al->SetIsMateMapped(!mate_unmapped);
    mate->SetIsMateMapped(!al_unmapped);
  }
}

void StoreAlignment(
    const bool& add_za,
    Alignment* al,
    map<string, Alignment> *al_map_cur,
    map<string, Alignment> *al_map_pre,
    BamTools::BamWriter* writer) {
  // Clear up the buffers once the al_map_cur buffer is full
  // 1. Clear up al_map_pre
  // 2. move al_map_cur to al_map_pre
  if ((static_cast<int>(al_map_cur->size()) > kAlignmentMapSize)) {
    WriteAlignment(add_za, al_map_pre, writer);
    al_map_pre->clear();
    map<string, Alignment> *tmp = al_map_pre;
    al_map_pre = al_map_cur;
    al_map_cur = tmp;
  }

  map<string, Alignment>::iterator ite_cur = al_map_cur->find(al->bam_alignment.Name);
  if (ite_cur == al_map_cur->end()) {
    if (!al_map_pre) {
      map<string, Alignment>::iterator ite_pre = al_map_pre->find(al->bam_alignment.Name);
      if (ite_pre == al_map_pre->end()) { // al is not found in cur or pre either
        (*al_map_cur)[al->bam_alignment.Name] = *al;
      } else { // find the mate in al_map_pre
        MarkAsUnmapped(&(al->bam_alignment), &(ite_pre->second.bam_alignment));
	WriteAlignment(add_za, ite_pre->second, al, writer);
        WriteAlignment(add_za, *al, &(ite_pre->second), writer);
        al_map_pre->erase(ite_pre);
      }
    } else { // al is not found in cur and pre is NULL
      (*al_map_cur)[al->bam_alignment.Name] = *al;
    }
  } else { // find the mate in al_map_cur
    MarkAsUnmapped(&(al->bam_alignment), &(ite_cur->second.bam_alignment));
    WriteAlignment(add_za, ite_cur->second, al, writer);
    WriteAlignment(add_za, *al, &(ite_cur->second), writer);
    al_map_cur->erase(ite_cur);
  }
    
}

bool ParseArguments(const int argc, char* const * argv, Param* param) {
  if (argc == 1) { // no argument
    ShowHelp();
    return false;
  }

  // record command line
  param->command_line = argv[0];
  for ( int i = 1; i < argc; ++i ) {
    param->command_line += " ";
    param->command_line += argv[i];
  }

  const char *short_option = "hi:o:r:z";
  const struct option long_option[] = {
    {"help", no_argument, NULL, 'h'},
    {"input", required_argument, NULL, 'i'},
    {"output", required_argument, NULL, 'o'},
    {"ref", required_argument, NULL, 'r'},
    {"no-za-add", no_argument, NULL, 'z'},

    {0, 0, 0, 0}
  };

  int c = 0;
  bool show_help = false;
  while (true) {
    int option_index = 0;
    c = getopt_long(argc, argv, short_option, long_option, &option_index);

    if (c == -1) // end of options
      break;

    switch (c) {
      case 'h': show_help = true; break;
      case 'i': param->in_bam = optarg; break;
      case 'o': param->out_bam = optarg; break;
      case 'r': param->ref_fasta = optarg; break;
      case 'z': param->za_add = false; break;
    }
  }

  if (show_help || param->in_bam.empty() 
   || param->out_bam.empty() || param->ref_fasta.empty()) {
    ShowHelp();
    return false;
  }

  return true;
}

int PickBestAlignment(const int& request_score, 
                      const StripedSmithWaterman::Alignment& alignment, 
		      const SpecialReference& s_ref) {
  if (alignment.sw_score < request_score) {
    return -1; // no proper alignment is found
  } else {
    int accu_len = 0;
    for (unsigned int i = 0; i < s_ref.ref_lens.size(); ++i) {
      accu_len += s_ref.ref_lens[i];
      if (alignment.ref_begin < accu_len) {
        if (alignment.ref_end < accu_len) return i;
	else return -1;
      }
    }
  }

  return -1;
}

bool IsProblematicAlignment(const BamTools::BamAlignment& al) {
  if (!al.IsMapped()) return true;
  if (al.RefID != al.MateRefID) return true;
  if (al.CigarData.size() > 5) return true;
  if (IsTooManyClips(al)) return true;

  return false;
}

int main(int argc, char** argv) {
  Param param;
  
  if (!ParseArguments(argc, argv, &param)) return 1;

  // Open input bam
  string infilename = param.in_bam;
  string outfilename = param.out_bam;
  BamTools::BamReader reader;
  BamTools::BamWriter writer;
  if (!OpenBams(infilename, outfilename, param.command_line, &reader, &writer)) return 1;

  // Get the ID of target chromosome

  // Open fasta
  FastaReference fasta;
  LoadReference(param.ref_fasta.c_str(), &fasta);

  // Build SSW aligners for every reference in fasta
  SpecialReference s_ref;
  ConcatenateSpecialReference(&fasta, &s_ref);

  // Build SSW aligner
  StripedSmithWaterman::Aligner aligner;
  aligner.SetReferenceSequence(s_ref.concatnated.c_str(), s_ref.concatnated_len);

  // CORE ALGORITHM
  BamTools::BamAlignment bam_alignment;
  map<string, Alignment> al_map1, al_map2;
  map<string, Alignment> *al_map_cur = &al_map1, *al_map_pre = &al_map2;
  StripedSmithWaterman::Alignment alignment;
  Alignment al;
  while (reader.GetNextAlignment(bam_alignment)) {
    int index = -1;
    if (param.za_add && IsProblematicAlignment(bam_alignment)) {
      Align(bam_alignment.QueryBases, aligner, &alignment);
      index = PickBestAlignment(bam_alignment.Length, alignment, s_ref);
      if (index == -1) { // try the reverse complement sequences
        string reverse;
        GetReverseComplement(bam_alignment.QueryBases, &reverse);
        Align(reverse, aligner, &alignment);
        index = PickBestAlignment(bam_alignment.Length, alignment, s_ref);
      }
    }
    al.Clear();
    al.bam_alignment = bam_alignment;
    al.hit_insertion = (index == -1) ? false: true;
    al.ins_prefix    = (index == -1) ? "" : s_ref.ref_names[index].substr(8,2);
    StoreAlignment(param.za_add, &al, al_map_cur, al_map_pre, &writer);
  }

  // Close
  WriteAlignment(param.za_add, &al_map1, &writer);
  WriteAlignment(param.za_add, &al_map2, &writer);
  al_map1.clear();
  al_map2.clear();
  reader.Close();
  writer.Close();
}

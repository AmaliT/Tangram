#include <stdio.h>
#include <limits.h>

#include <vector>

#include "api/BamReader.h"
#include "api/BamWriter.h"
#include "../OutSources/fasta/Fasta.h"
#include "../OutSources/stripedSW/ssw_cpp.h"

using namespace std;

static const StripedSmithWaterman::Filter kFilter(false, false, 0, 32467);

void ShowHelp() {
  fprintf(stderr, "Usage: tangram_bam <in_bam> <ref_fa> <out_bam>\n\n");
  fprintf(stderr, "tangram_bam will generate ZA tags for bams");
  fprintf(stderr, " that are not generated by MOSAIK.\n");

  fprintf(stderr, "<ref_fa> is a fasta file containing insertion sequences\n");
  fprintf(stderr, " that we are going to detect them.\n");
}

bool OpenBams(
    const string& infilename,
    const string& outfilename,
    BamTools::BamReader* reader,
    BamTools::BamWriter* writer) {
  
  reader->Open(infilename);
  if (!reader->IsOpen()) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", infilename.c_str());
    return false;
  }

  // Load header and ref
  string header = reader->GetHeaderText();
  BamTools::RefVector ref = reader->GetReferenceData();

  if (!writer->Open(outfilename, header, ref)) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", outfilename.c_str());
    reader->Close();
    return false;
  }

  return true;
}

inline bool LoadReference(const char* fa, FastaReference* fasta) {
  string filename = fa;
  fasta->open(filename);

  return true;
}

bool BuildAligner(
    FastaReference* fasta, 
    vector<StripedSmithWaterman::Aligner*>* aligners,
    vector<string>* ref_names) {
  for (vector<string>::const_iterator ite = fasta->index->sequenceNames.begin();
       ite != fasta->index->sequenceNames.end(); ++ite) {
    StripedSmithWaterman::Aligner* al_ptr = new StripedSmithWaterman::Aligner;
    al_ptr->SetReferenceSequence(fasta->getSequence(*ite).c_str(), 
                                 fasta->sequenceLength(*ite));
    aligners->push_back(al_ptr);
    ref_names->push_back(*ite);
  }

  return true;
}

void Align(
    const string& query,
    const vector<StripedSmithWaterman::Aligner*>& aligners,
    vector<StripedSmithWaterman::Alignment>* alignments) {
  for (unsigned int i = 0; i < aligners.size(); ++i) {
    (*alignments)[i].Clear();
    aligners[i]->Align(query.c_str(), kFilter, &((*alignments)[i]));
  }
}

int PickBestAlignment(
    const int& request_score,
    const vector<StripedSmithWaterman::Alignment>& alignments) {
  
  int sw_score_max = INT_MIN;
  int index = 0;
  for (unsigned int i = 0; i < alignments.size(); ++i) {
    if (alignments[i].sw_score > sw_score_max) {
      sw_score_max = alignments[i].sw_score;
      index = i;
    }
  }

  if (sw_score_max > request_score) return index;
  else return -1;
}

int main(int argc, char** argv) {
  if (argc != 4) {
    ShowHelp();
    return 1;
  }

  // Open input bam
  string infilename = argv[1];
  string outfilename = argv[3];
  BamTools::BamReader reader;
  BamTools::BamWriter writer;
  if (!OpenBams(infilename, outfilename, &reader, &writer)) return 1;

  // Open fasta
  FastaReference fasta;
  LoadReference(argv[2], &fasta);

  // Build SSW aligners for every reference in fasta
  vector<StripedSmithWaterman::Aligner*> aligners;
  vector<string> ref_names;
  BuildAligner(&fasta, &aligners, &ref_names);

  // Prepare alignment vector
  vector<StripedSmithWaterman::Alignment> alignments(aligners.size());

  // CORE ALGORITHM
  BamTools::BamAlignment bam_alignment;
  while (reader.GetNextAlignment(bam_alignment)) {
    Align(bam_alignment.QueryBases, aligners, &alignments);
    int index = PickBestAlignment(bam_alignment.Length, alignments);
  }

  // Close
  reader.Close();
  writer.Close();
  for (vector<StripedSmithWaterman::Aligner*>::iterator ite = aligners.begin();
       ite != aligners.end(); ++ite)
    free(*ite);
}

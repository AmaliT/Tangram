#include <stdio.h>
#include <limits.h>

#include <vector>
#include <string>
#include <iostream>

#include "api/BamReader.h"
#include "api/BamWriter.h"
#include "../OutSources/fasta/Fasta.h"
#include "../OutSources/stripedSW/ssw_cpp.h"

using namespace std;

const StripedSmithWaterman::Filter kFilter(false, false, 0, 32467);
const int kAlignmentMapSize = 10000;

struct Alignment {
  BamTools::BamAlignment bam_alignment;
  bool hit_insertion;
  string ins_prefix;

  Alignment()
      : bam_alignment()
      , hit_insertion(false)
      , ins_prefix()
  {}

  void Clear() {
    hit_insertion = false;
    ins_prefix.clear();
  }
};

void ShowHelp() {
  fprintf(stderr, "Usage: tangram_bam <in_bam> <ref_fa> <out_bam>\n\n");
  fprintf(stderr, "tangram_bam will generate ZA tags for bams");
  fprintf(stderr, " that are not generated by MOSAIK.\n");

  fprintf(stderr, "<ref_fa> is a fasta file containing insertion sequences\n");
  fprintf(stderr, " that we are going to detect them.\n");
}

bool OpenBams(
    const string& infilename,
    const string& outfilename,
    const int& no_arg,
    char** arguments,
    BamTools::BamReader* reader,
    BamTools::BamWriter* writer) {
  
  reader->Open(infilename);
  if (!reader->IsOpen()) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", infilename.c_str());
    return false;
  }

  // Load header and ref
  string header = reader->GetHeaderText();
  size_t pos1 = header.find("SO:");
  if (pos1 != string::npos) {
    size_t pos2 = header.find("SO:queryname");
    if (pos2 != string::npos) header.replace(pos2, 12, "SO:unsorted");
    pos2 = header.find("SO:coordinate");
    if (pos2 != string::npos) header.replace(pos2, 13, "SO:unsorted");
  }
  header += "@PG\tID:tangram_bam\tCL:";
  for (int i = 0; i < no_arg; ++i) {
    header += arguments[i];
  }
  header += "\n";
  BamTools::RefVector ref = reader->GetReferenceData();

  if (!writer->Open(outfilename, header, ref)) {
    fprintf(stderr, "ERROR: The bam file, %s, cannot be open\n", outfilename.c_str());
    reader->Close();
    return false;
  }

  return true;
}

inline bool LoadReference(const char* fa, FastaReference* fasta) {
  string filename = fa;
  fasta->open(filename);

  return true;
}

bool BuildAligner(
    FastaReference* fasta, 
    vector<StripedSmithWaterman::Aligner*>* aligners,
    vector<string>* ref_names) {
  for (vector<string>::const_iterator ite = fasta->index->sequenceNames.begin();
       ite != fasta->index->sequenceNames.end(); ++ite) {
    StripedSmithWaterman::Aligner* al_ptr = new StripedSmithWaterman::Aligner;
    al_ptr->SetReferenceSequence(fasta->getSequence(*ite).c_str(), 
                                 fasta->sequenceLength(*ite));
    aligners->push_back(al_ptr);
    ref_names->push_back(*ite);
  }

  return true;
}

void Align(
    const string& query,
    const vector<StripedSmithWaterman::Aligner*>& aligners,
    vector<StripedSmithWaterman::Alignment>* alignments) {
  for (unsigned int i = 0; i < aligners.size(); ++i) {
    (*alignments)[i].Clear();
    aligners[i]->Align(query.c_str(), kFilter, &((*alignments)[i]));
  }
}

int PickBestAlignment(
    const int& request_score,
    const vector<StripedSmithWaterman::Alignment>& alignments) {
  
  int sw_score_max = INT_MIN;
  int index = 0;
  for (unsigned int i = 0; i < alignments.size(); ++i) {
    if (alignments[i].sw_score > sw_score_max) {
      sw_score_max = alignments[i].sw_score;
      index = i;
    }
  }

  if (sw_score_max > request_score) return index;
  else return -1;
}

void GetZa(const Alignment& al, const Alignment& mate, string* za) {
  const bool mate1 = al.bam_alignment.IsFirstMate();
  Alignment const *mate1_ptr, *mate2_ptr;

  if (mate1) {
    *za = "<@;";
    mate1_ptr = &al;
    mate2_ptr = &mate;
  } else {
    *za = "<&;";
    mate1_ptr = &mate;
    mate2_ptr = &al;
  }

  *za += (std::to_string(mate1_ptr->bam_alignment.MapQuality) + ";;" 
          + (mate1_ptr->hit_insertion ? mate1_ptr->ins_prefix : "") 
	  + ";1;");
  
  if (mate1) {
    *za += ";><&;";
  } else {
    *za += ";><@;";
  }

  *za += (std::to_string(mate2_ptr->bam_alignment.MapQuality) + ";;" 
          + (mate2_ptr->hit_insertion ? mate2_ptr->ins_prefix : "") 
	  + ";1;;>");

}

void WriteAlignment(
    const Alignment& mate,
    Alignment* al,
    BamTools::BamWriter* writer) {
  string za;
  GetZa(*al, mate, &za);

  al->bam_alignment.AddTag("ZA","Z",za);

  writer->SaveAlignment(al->bam_alignment);
}

void WriteAlignment(map<string, Alignment>* al_map_ite, 
                    BamTools::BamWriter* writer) {
  for (map<string, Alignment>::iterator ite = al_map_ite->begin();
       ite != al_map_ite->end(); ++ite) {
    Alignment* al = &(ite->second);
    string za;
    if (al->bam_alignment.IsPaired()) {
      if (al->bam_alignment.IsFirstMate()) {
        za = "<@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
             + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>"
	     + "<&;;;;;;>";
      } else {
        za = "<&;;;;;;><@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
             + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>";
      }
    } else {
      za = "<@;" + std::to_string(al->bam_alignment.MapQuality) + ";;"
           + (al->hit_insertion ? al->ins_prefix : "") + ";1;;>";
    }

    al->bam_alignment.AddTag("ZA","Z",za);
    writer->SaveAlignment(al->bam_alignment);
  }
}

void StoreAlignment(
    Alignment* al,
    map<string, Alignment> *al_map_cur,
    map<string, Alignment> *al_map_pre,
    BamTools::BamWriter* writer) {
  if ((static_cast<int>(al_map_cur->size()) > kAlignmentMapSize)) {
    WriteAlignment(al_map_pre, writer);
    al_map_pre->clear();
    map<string, Alignment> *tmp = al_map_pre;
    al_map_pre = al_map_cur;
    al_map_cur = tmp;

  }

  map<string, Alignment>::iterator ite_cur = al_map_cur->find(al->bam_alignment.Name);
  if (ite_cur == al_map_cur->end()) {
    if (!al_map_pre) {
      map<string, Alignment>::iterator ite_pre = al_map_pre->find(al->bam_alignment.Name);
      if (ite_pre == al_map_pre->end()) { // al is not found in cur or pre either
        (*al_map_cur)[al->bam_alignment.Name] = *al;
      } else { // find the mate in al_map_pre
        WriteAlignment(ite_pre->second, al, writer);
        WriteAlignment(*al, &(ite_pre->second), writer);
        al_map_pre->erase(ite_pre);
      }
    } else { // al is not found in cur and pre is NULL
      (*al_map_cur)[al->bam_alignment.Name] = *al;
    }
  } else { // find the mate in al_map_cur
    WriteAlignment(ite_cur->second, al, writer);
    WriteAlignment(*al, &(ite_cur->second), writer);
    al_map_cur->erase(ite_cur);
  }
    
}

int main(int argc, char** argv) {
  if (argc != 4) {
    ShowHelp();
    return 1;
  }

  // Open input bam
  string infilename = argv[1];
  string outfilename = argv[3];
  BamTools::BamReader reader;
  BamTools::BamWriter writer;
  if (!OpenBams(infilename, outfilename, argc, argv, &reader, &writer)) return 1;

  // Open fasta
  FastaReference fasta;
  LoadReference(argv[2], &fasta);

  // Build SSW aligners for every reference in fasta
  vector<StripedSmithWaterman::Aligner*> aligners;
  vector<string> ref_names;
  BuildAligner(&fasta, &aligners, &ref_names);

  // Prepare alignment vector
  vector<StripedSmithWaterman::Alignment> alignments(aligners.size());

  // CORE ALGORITHM
  BamTools::BamAlignment bam_alignment;
  map<string, Alignment> al_map1, al_map2;
  map<string, Alignment> *al_map_cur = &al_map1, *al_map_pre = &al_map2;
  Alignment al;
  while (reader.GetNextAlignment(bam_alignment)) {
    Align(bam_alignment.QueryBases, aligners, &alignments);
    int index = PickBestAlignment(bam_alignment.Length, alignments);
    al.Clear();
    al.bam_alignment = bam_alignment;
    al.hit_insertion = (index == -1) ? false: true;
    al.ins_prefix    = (index == -1) ? "" : ref_names[index].substr(8,2);
    StoreAlignment(&al, al_map_cur, al_map_pre, &writer);
  }

  // Close
  WriteAlignment(&al_map1, &writer);
  WriteAlignment(&al_map2, &writer);
  al_map1.clear();
  al_map2.clear();
  reader.Close();
  writer.Close();
  for (vector<StripedSmithWaterman::Aligner*>::iterator ite = aligners.begin();
       ite != aligners.end(); ++ite)
    free(*ite);
}
